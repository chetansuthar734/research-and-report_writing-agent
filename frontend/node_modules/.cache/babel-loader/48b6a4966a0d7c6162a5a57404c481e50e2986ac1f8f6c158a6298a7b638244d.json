{"ast":null,"code":"import { z } from \"zod/v3\";\nimport pRetry from \"p-retry\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { isTraceableFunction } from \"langsmith/singletons/traceable\";\nimport { LogStreamCallbackHandler, RunLog, RunLogPatch, isLogStreamHandler } from \"../tracers/log_stream.js\";\nimport { EventStreamCallbackHandler, isStreamEventsHandler } from \"../tracers/event_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream, concat, atee, pipeGeneratorWithSetup, AsyncGeneratorWithSetup } from \"../utils/stream.js\";\nimport { raceWithSignal } from \"../utils/signal.js\";\nimport { DEFAULT_RECURSION_LIMIT, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, pickRunnableConfigKeys } from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter, isRunnableInterface } from \"./utils.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { Graph } from \"./graph.js\";\nimport { convertToHttpEventStream } from \"./wrappers.js\";\nimport { consumeAsyncIterableInContext, consumeIteratorInContext, isAsyncIterable, isIterableIterator, isIterator } from \"./iter.js\";\nimport { _isToolCall, ToolInputParsingException } from \"../tools/utils.js\";\nimport { getSchemaDescription, interopParseAsync, isSimpleStringZodSchema } from \"../utils/types/zod.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value, defaultKey) {\n  return value && !Array.isArray(value) &&\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  !(value instanceof Date) && typeof value === \"object\" ? value : {\n    [defaultKey]: value\n  };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  getName(suffix) {\n    const name =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n    return suffix ? `${name}${suffix}` : name;\n  }\n  /**\n   * Bind arguments to a Runnable, returning a new Runnable.\n   * @param kwargs\n   * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n   *\n   * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n   */\n  bind(kwargs) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      kwargs,\n      config: {}\n    });\n  }\n  /**\n   * Return a new Runnable that maps a list of inputs to a list of outputs,\n   * by calling invoke() with each input.\n   *\n   * @deprecated This will be removed in the next breaking release.\n   */\n  map() {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableEach({\n      bound: this\n    });\n  }\n  /**\n   * Add retry logic to an existing runnable.\n   * @param fields.stopAfterAttempt The number of attempts to retry.\n   * @param fields.onFailedAttempt A function that is called when a retry fails.\n   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n   */\n  withRetry(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this,\n      kwargs: {},\n      config: {},\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields\n    });\n  }\n  /**\n   * Bind config to a Runnable, returning a new Runnable.\n   * @param config New configuration parameters to attach to the new runnable.\n   * @returns A new RunnableBinding with a config matching what's passed.\n   */\n  withConfig(config) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config,\n      kwargs: {}\n    });\n  }\n  /**\n   * Create a new runnable from the current one that will try invoking\n   * other passed fallback runnables if the initial invocation fails.\n   * @param fields.fallbacks Other runnables to call if the runnable errors.\n   * @returns A new RunnableWithFallbacks.\n   */\n  withFallbacks(fields) {\n    const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableWithFallbacks({\n      runnable: this,\n      fallbacks\n    });\n  }\n  _getOptionsList(options, length = 0) {\n    if (Array.isArray(options) && options.length !== length) {\n      throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n    }\n    if (Array.isArray(options)) {\n      return options.map(ensureConfig);\n    }\n    if (length > 1 && !Array.isArray(options) && options.runId) {\n      console.warn(\"Provided runId will be used only for the first element of the batch.\");\n      const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n      return Array.from({\n        length\n      }, (_, i) => ensureConfig(i === 0 ? options : subsequent));\n    }\n    return Array.from({\n      length\n    }, () => ensureConfig(options));\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const caller = new AsyncCaller({\n      maxConcurrency,\n      onFailedAttempt: e => {\n        throw e;\n      }\n    });\n    const batchCalls = inputs.map((input, i) => caller.call(async () => {\n      try {\n        const result = await this.invoke(input, configList[i]);\n        return result;\n      } catch (e) {\n        if (batchOptions?.returnExceptions) {\n          return e;\n        }\n        throw e;\n      }\n    }));\n    return Promise.all(batchCalls);\n  }\n  /**\n   * Default streaming implementation.\n   * Subclasses should override this method if they support streaming output.\n   * @param input\n   * @param options\n   */\n  async *_streamIterator(input, options) {\n    yield this.invoke(input, options);\n  }\n  /**\n   * Stream output in chunks.\n   * @param input\n   * @param options\n   * @returns A readable stream that is also an iterable.\n   */\n  async stream(input, options) {\n    // Buffer the first streamed chunk to allow for initial errors\n    // to surface immediately.\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this._streamIterator(input, config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n  _separateRunnableConfigFromCallOptions(options) {\n    let runnableConfig;\n    if (options === undefined) {\n      runnableConfig = ensureConfig(options);\n    } else {\n      runnableConfig = ensureConfig({\n        callbacks: options.callbacks,\n        tags: options.tags,\n        metadata: options.metadata,\n        runName: options.runName,\n        configurable: options.configurable,\n        recursionLimit: options.recursionLimit,\n        maxConcurrency: options.maxConcurrency,\n        runId: options.runId,\n        timeout: options.timeout,\n        signal: options.signal\n      });\n    }\n    const callOptions = {\n      ...options\n    };\n    delete callOptions.callbacks;\n    delete callOptions.tags;\n    delete callOptions.metadata;\n    delete callOptions.runName;\n    delete callOptions.configurable;\n    delete callOptions.recursionLimit;\n    delete callOptions.maxConcurrency;\n    delete callOptions.runId;\n    delete callOptions.timeout;\n    delete callOptions.signal;\n    return [runnableConfig, callOptions];\n  }\n  async _callWithConfig(func, input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n    delete config.runId;\n    let output;\n    try {\n      const promise = func.call(this, input, config, runManager);\n      output = await raceWithSignal(promise, options?.signal);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    return output;\n  }\n  /**\n   * Internal method that handles batching and configuration for a runnable\n   * It takes a function, input values, and optional configuration, and\n   * returns a promise that resolves to the output values.\n   * @param func The function to be executed for each input value.\n   * @param input The input values to be processed.\n   * @param config Optional configuration for the function execution.\n   * @returns A promise that resolves to the output values.\n   */\n  async _batchWithConfig(func, inputs, options, batchOptions) {\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));\n    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n      delete optionsList[i].runId;\n      return handleStartRes;\n    }));\n    let outputs;\n    try {\n      const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);\n      outputs = await raceWithSignal(promise, optionsList?.[0]?.signal);\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n    return outputs;\n  }\n  /**\n   * Helper method to transform an Iterator of Input values into an Iterator of\n   * Output values, with callbacks.\n   * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n   */\n  async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n    let finalInput;\n    let finalInputSupported = true;\n    let finalOutput;\n    let finalOutputSupported = true;\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    async function* wrapInputForTracing() {\n      for await (const chunk of inputGenerator) {\n        if (finalInputSupported) {\n          if (finalInput === undefined) {\n            finalInput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalInput = concat(finalInput, chunk);\n            } catch {\n              finalInput = undefined;\n              finalInputSupported = false;\n            }\n          }\n        }\n        yield chunk;\n      }\n    }\n    let runManager;\n    try {\n      const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), {\n        input: \"\"\n      }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), options?.signal, config);\n      delete config.runId;\n      runManager = pipe.setup;\n      const streamEventsHandler = runManager?.handlers.find(isStreamEventsHandler);\n      let iterator = pipe.output;\n      if (streamEventsHandler !== undefined && runManager !== undefined) {\n        iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n      }\n      const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n      if (streamLogHandler !== undefined && runManager !== undefined) {\n        iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n      }\n      for await (const chunk of iterator) {\n        yield chunk;\n        if (finalOutputSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = concat(finalOutput, chunk);\n            } catch {\n              finalOutput = undefined;\n              finalOutputSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e, undefined, undefined, undefined, {\n        inputs: _coerceToDict(finalInput, \"input\")\n      });\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, {\n      inputs: _coerceToDict(finalInput, \"input\")\n    });\n  }\n  getGraph(_) {\n    const graph = new Graph();\n    // TODO: Add input schema for runnables\n    const inputNode = graph.addNode({\n      name: `${this.getName()}Input`,\n      schema: z.any()\n    });\n    const runnableNode = graph.addNode(this);\n    // TODO: Add output schemas for runnables\n    const outputNode = graph.addNode({\n      name: `${this.getName()}Output`,\n      schema: z.any()\n    });\n    graph.addEdge(inputNode, runnableNode);\n    graph.addEdge(runnableNode, outputNode);\n    return graph;\n  }\n  /**\n   * Create a new runnable sequence that runs each individual runnable in series,\n   * piping the output of one runnable into another runnable or runnable-like.\n   * @param coerceable A runnable, function, or object whose values are functions or runnables.\n   * @returns A new runnable sequence.\n   */\n  pipe(coerceable) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableSequence({\n      first: this,\n      last: _coerceToRunnable(coerceable)\n    });\n  }\n  /**\n   * Pick keys from the dict output of this runnable. Returns a new runnable.\n   */\n  pick(keys) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return this.pipe(new RunnablePick(keys));\n  }\n  /**\n   * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n   */\n  assign(mapping) {\n    return this.pipe(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    new RunnableAssign(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    new RunnableMap({\n      steps: mapping\n    })));\n  }\n  /**\n   * Default implementation of transform, which buffers input and then calls stream.\n   * Subclasses should override this method if they can start producing output while\n   * input is still being generated.\n   * @param generator\n   * @param options\n   */\n  async *transform(generator, options) {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        // This method should throw an error if gathering fails.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        finalChunk = concat(finalChunk, chunk);\n      }\n    }\n    yield* this._streamIterator(finalChunk, ensureConfig(options));\n  }\n  /**\n   * Stream all output from a runnable, as reported to the callback system.\n   * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n   * Output is streamed as Log objects, which include a list of\n   * jsonpatch ops that describe how the state of the run has changed in each\n   * step, and the final state of the run.\n   * The jsonpatch ops can be applied in order to construct state.\n   * @param input\n   * @param options\n   * @param streamOptions\n   */\n  async *streamLog(input, options, streamOptions) {\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"original\"\n    });\n    const config = ensureConfig(options);\n    yield* this._streamLog(input, logStreamCallbackHandler, config);\n  }\n  async *_streamLog(input, logStreamCallbackHandler, config) {\n    const {\n      callbacks\n    } = config;\n    if (callbacks === undefined) {\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = [logStreamCallbackHandler];\n    } else if (Array.isArray(callbacks)) {\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = copiedCallbacks;\n    }\n    const runnableStreamPromise = this.stream(input, config);\n    async function consumeRunnableStream() {\n      try {\n        const runnableStream = await runnableStreamPromise;\n        for await (const chunk of runnableStream) {\n          const patch = new RunLogPatch({\n            ops: [{\n              op: \"add\",\n              path: \"/streamed_output/-\",\n              value: chunk\n            }]\n          });\n          await logStreamCallbackHandler.writer.write(patch);\n        }\n      } finally {\n        await logStreamCallbackHandler.writer.close();\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    try {\n      for await (const log of logStreamCallbackHandler) {\n        yield log;\n      }\n    } finally {\n      await runnableStreamConsumePromise;\n    }\n  }\n  streamEvents(input, options, streamOptions) {\n    let stream;\n    if (options.version === \"v1\") {\n      stream = this._streamEventsV1(input, options, streamOptions);\n    } else if (options.version === \"v2\") {\n      stream = this._streamEventsV2(input, options, streamOptions);\n    } else {\n      throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n    }\n    if (options.encoding === \"text/event-stream\") {\n      return convertToHttpEventStream(stream);\n    } else {\n      return IterableReadableStream.fromAsyncGenerator(stream);\n    }\n  }\n  async *_streamEventsV2(input, options, streamOptions) {\n    const eventStreamer = new EventStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false\n    });\n    const config = ensureConfig(options);\n    const runId = config.runId ?? uuidv4();\n    config.runId = runId;\n    const callbacks = config.callbacks;\n    if (callbacks === undefined) {\n      config.callbacks = [eventStreamer];\n    } else if (Array.isArray(callbacks)) {\n      config.callbacks = callbacks.concat(eventStreamer);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.addHandler(eventStreamer, true);\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = copiedCallbacks;\n    }\n    const abortController = new AbortController();\n    // Call the runnable in streaming mode,\n    // add each chunk to the output stream\n    const outerThis = this;\n    async function consumeRunnableStream() {\n      let signal;\n      let listener = null;\n      try {\n        if (options?.signal) {\n          if (\"any\" in AbortSignal) {\n            // Use native AbortSignal.any() if available (Node 19+)\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            signal = AbortSignal.any([abortController.signal, options.signal]);\n          } else {\n            // Fallback for Node 18 and below - just use the provided signal\n            signal = options.signal;\n            // Ensure we still abort our controller when the parent signal aborts\n            listener = () => {\n              abortController.abort();\n            };\n            options.signal.addEventListener(\"abort\", listener, {\n              once: true\n            });\n          }\n        } else {\n          signal = abortController.signal;\n        }\n        const runnableStream = await outerThis.stream(input, {\n          ...config,\n          signal\n        });\n        const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for await (const _ of tappedStream) {\n          // Just iterate so that the callback handler picks up events\n          if (abortController.signal.aborted) break;\n        }\n      } finally {\n        await eventStreamer.finish();\n        if (signal && listener) {\n          signal.removeEventListener(\"abort\", listener);\n        }\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    let firstEventSent = false;\n    let firstEventRunId;\n    try {\n      for await (const event of eventStreamer) {\n        // This is a work-around an issue where the inputs into the\n        // chain are not available until the entire input is consumed.\n        // As a temporary solution, we'll modify the input to be the input\n        // that was passed into the chain.\n        if (!firstEventSent) {\n          event.data.input = input;\n          firstEventSent = true;\n          firstEventRunId = event.run_id;\n          yield event;\n          continue;\n        }\n        if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n          // If it's the end event corresponding to the root runnable\n          // we dont include the input in the event since it's guaranteed\n          // to be included in the first event.\n          if (event.data?.input) {\n            delete event.data.input;\n          }\n        }\n        yield event;\n      }\n    } finally {\n      abortController.abort();\n      await runnableStreamConsumePromise;\n    }\n  }\n  async *_streamEventsV1(input, options, streamOptions) {\n    let runLog;\n    let hasEncounteredStartEvent = false;\n    const config = ensureConfig(options);\n    const rootTags = config.tags ?? [];\n    const rootMetadata = config.metadata ?? {};\n    const rootName = config.runName ?? this.getName();\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"streaming_events\"\n    });\n    const rootEventFilter = new _RootEventFilter({\n      ...streamOptions\n    });\n    const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n    for await (const log of logStream) {\n      if (!runLog) {\n        runLog = RunLog.fromRunLogPatch(log);\n      } else {\n        runLog = runLog.concat(log);\n      }\n      if (runLog.state === undefined) {\n        throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n      }\n      // Yield the start event for the root runnable if it hasn't been seen.\n      // The root run is never filtered out\n      if (!hasEncounteredStartEvent) {\n        hasEncounteredStartEvent = true;\n        const state = {\n          ...runLog.state\n        };\n        const event = {\n          run_id: state.id,\n          event: `on_${state.type}_start`,\n          name: rootName,\n          tags: rootTags,\n          metadata: rootMetadata,\n          data: {\n            input\n          }\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n      const paths = log.ops.filter(op => op.path.startsWith(\"/logs/\")).map(op => op.path.split(\"/\")[2]);\n      const dedupedPaths = [...new Set(paths)];\n      for (const path of dedupedPaths) {\n        let eventType;\n        let data = {};\n        const logEntry = runLog.state.logs[path];\n        if (logEntry.end_time === undefined) {\n          if (logEntry.streamed_output.length > 0) {\n            eventType = \"stream\";\n          } else {\n            eventType = \"start\";\n          }\n        } else {\n          eventType = \"end\";\n        }\n        if (eventType === \"start\") {\n          // Include the inputs with the start event if they are available.\n          // Usually they will NOT be available for components that operate\n          // on streams, since those components stream the input and\n          // don't know its final value until the end of the stream.\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n        } else if (eventType === \"end\") {\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n          data.output = logEntry.final_output;\n        } else if (eventType === \"stream\") {\n          const chunkCount = logEntry.streamed_output.length;\n          if (chunkCount !== 1) {\n            throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n          }\n          data = {\n            chunk: logEntry.streamed_output[0]\n          };\n          // Clean up the stream, we don't need it anymore.\n          // And this avoids duplicates as well!\n          logEntry.streamed_output = [];\n        }\n        yield {\n          event: `on_${logEntry.type}_${eventType}`,\n          name: logEntry.name,\n          run_id: logEntry.id,\n          tags: logEntry.tags,\n          metadata: logEntry.metadata,\n          data\n        };\n      }\n      // Finally, we take care of the streaming output from the root chain\n      // if there is any.\n      const {\n        state\n      } = runLog;\n      if (state.streamed_output.length > 0) {\n        const chunkCount = state.streamed_output.length;\n        if (chunkCount !== 1) {\n          throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n        }\n        const data = {\n          chunk: state.streamed_output[0]\n        };\n        // Clean up the stream, we don't need it anymore.\n        state.streamed_output = [];\n        const event = {\n          event: `on_${state.type}_stream`,\n          run_id: state.id,\n          tags: rootTags,\n          metadata: rootMetadata,\n          name: rootName,\n          data\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n    }\n    const state = runLog?.state;\n    if (state !== undefined) {\n      // Finally, yield the end event for the root runnable.\n      const event = {\n        event: `on_${state.type}_end`,\n        name: rootName,\n        run_id: state.id,\n        tags: rootTags,\n        metadata: rootMetadata,\n        data: {\n          output: state.final_output\n        }\n      };\n      if (rootEventFilter.includeEvent(event, state.type)) yield event;\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnable(thing) {\n    return isRunnableInterface(thing);\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config: {},\n      configFactories: [config => ({\n        callbacks: [new RootListenersTracer({\n          config,\n          onStart,\n          onEnd,\n          onError\n        })]\n      })]\n    });\n  }\n  /**\n   * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n   * which contains the runnable, name, description and schema.\n   *\n   * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n   *\n   * @param fields\n   * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n   * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n   * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n   * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n   */\n  asTool(fields) {\n    return convertRunnableToTool(this, fields);\n  }\n}\n/**\n * Wraps a runnable and applies partial config upon invocation.\n *\n * @example\n * ```typescript\n * import {\n *   type RunnableConfig,\n *   RunnableLambda,\n * } from \"@langchain/core/runnables\";\n *\n * const enhanceProfile = (\n *   profile: Record<string, any>,\n *   config?: RunnableConfig\n * ) => {\n *   if (config?.configurable?.role) {\n *     return { ...profile, role: config.configurable.role };\n *   }\n *   return profile;\n * };\n *\n * const runnable = RunnableLambda.from(enhanceProfile);\n *\n * // Bind configuration to the runnable to set the user's role dynamically\n * const adminRunnable = runnable.bind({ configurable: { role: \"Admin\" } });\n * const userRunnable = runnable.bind({ configurable: { role: \"User\" } });\n *\n * const result1 = await adminRunnable.invoke({\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * });\n *\n * // { name: \"Alice\", email: \"alice@example.com\", role: \"Admin\" }\n *\n * const result2 = await userRunnable.invoke({\n *   name: \"Bob\",\n *   email: \"bob@example.com\"\n * });\n *\n * // { name: \"Bob\", email: \"bob@example.com\", role: \"User\" }\n * ```\n */\nexport class RunnableBinding extends Runnable {\n  static lc_name() {\n    return \"RunnableBinding\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"config\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"kwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"configFactories\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n    this.kwargs = fields.kwargs;\n    this.config = fields.config;\n    this.configFactories = fields.configFactories;\n  }\n  getName(suffix) {\n    return this.bound.getName(suffix);\n  }\n  async _mergeConfig(...options) {\n    const config = mergeConfigs(this.config, ...options);\n    return mergeConfigs(config, ...(this.configFactories ? await Promise.all(this.configFactories.map(async configFactory => await configFactory(config))) : []));\n  }\n  /**\n   * Binds the runnable with the specified arguments.\n   * @param kwargs The arguments to bind the runnable with.\n   * @returns A new instance of the `RunnableBinding` class that is bound with the specified arguments.\n   *\n   * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n   */\n  bind(kwargs) {\n    return new this.constructor({\n      bound: this.bound,\n      kwargs: {\n        ...this.kwargs,\n        ...kwargs\n      },\n      config: this.config\n    });\n  }\n  withConfig(config) {\n    return new this.constructor({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: {\n        ...this.config,\n        ...config\n      }\n    });\n  }\n  withRetry(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields\n    });\n  }\n  async invoke(input, options) {\n    return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async batch(inputs, options, batchOptions) {\n    const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async individualOption => this._mergeConfig(ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(ensureConfig(options), this.kwargs);\n    return this.bound.batch(inputs, mergedOptions, batchOptions);\n  }\n  async *_streamIterator(input, options) {\n    yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async stream(input, options) {\n    return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async *transform(generator, options) {\n    yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  streamEvents(input, options, streamOptions) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const outerThis = this;\n    const generator = async function* () {\n      yield* outerThis.bound.streamEvents(input, {\n        ...(await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs)),\n        version: options.version\n      }, streamOptions);\n    };\n    return IterableReadableStream.fromAsyncGenerator(generator());\n  }\n  static isRunnableBinding(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  thing\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    return thing.bound && Runnable.isRunnable(thing.bound);\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    return new RunnableBinding({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      configFactories: [config => ({\n        callbacks: [new RootListenersTracer({\n          config,\n          onStart,\n          onEnd,\n          onError\n        })]\n      })]\n    });\n  }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n * @example\n * ```typescript\n * import { RunnableEach, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const toUpperCase = (input: string): string => input.toUpperCase();\n * const addGreeting = (input: string): string => `Hello, ${input}!`;\n *\n * const upperCaseLambda = RunnableLambda.from(toUpperCase);\n * const greetingLambda = RunnableLambda.from(addGreeting);\n *\n * const chain = new RunnableEach({\n *   bound: upperCaseLambda.pipe(greetingLambda),\n * });\n *\n * const result = await chain.invoke([\"alice\", \"bob\", \"carol\"])\n *\n * // [\"Hello, ALICE!\", \"Hello, BOB!\", \"Hello, CAROL!\"]\n * ```\n *\n * @deprecated This will be removed in the next breaking release.\n */\nexport class RunnableEach extends Runnable {\n  static lc_name() {\n    return \"RunnableEach\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n  }\n  /**\n   * Binds the runnable with the specified arguments.\n   * @param kwargs The arguments to bind the runnable with.\n   * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n   *\n   * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n   */\n  bind(kwargs) {\n    return new RunnableEach({\n      bound: this.bound.bind(kwargs)\n    });\n  }\n  /**\n   * Invokes the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(inputs, config) {\n    return this._callWithConfig(this._invoke.bind(this), inputs, config);\n  }\n  /**\n   * A helper method that is used to invoke the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async _invoke(inputs, config, runManager) {\n    return this.bound.batch(inputs, patchConfig(config, {\n      callbacks: runManager?.getChild()\n    }));\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    return new RunnableEach({\n      bound: this.bound.withListeners({\n        onStart,\n        onEnd,\n        onError\n      })\n    });\n  }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableRetry,\n * } from \"@langchain/core/runnables\";\n *\n * // Simulate an API call that fails\n * const simulateApiCall = (input: string): string => {\n *   console.log(`Attempting API call with input: ${input}`);\n *   throw new Error(\"API call failed due to network issue\");\n * };\n *\n * const apiCallLambda = RunnableLambda.from(simulateApiCall);\n *\n * // Apply retry logic using the .withRetry() method\n * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });\n *\n * // Alternatively, create a RunnableRetry instance manually\n * const manualRetry = new RunnableRetry({\n *   bound: apiCallLambda,\n *   maxAttemptNumber: 3,\n *   config: {},\n * });\n *\n * // Example invocation using the .withRetry() method\n * const res = await apiCallWithRetry\n *   .invoke(\"Request 1\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n *\n * // Example invocation using the manual retry instance\n * const res2 = await manualRetry\n *   .invoke(\"Request 2\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n * ```\n */\nexport class RunnableRetry extends RunnableBinding {\n  static lc_name() {\n    return \"RunnableRetry\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"maxAttemptNumber\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"onFailedAttempt\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: () => {}\n    });\n    this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n    this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n  }\n  _patchConfigForRetry(attempt, config, runManager) {\n    const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n    return patchConfig(config, {\n      callbacks: runManager?.getChild(tag)\n    });\n  }\n  async _invoke(input, config, runManager) {\n    return pRetry(attemptNumber => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onFailedAttempt: error => this.onFailedAttempt(error, input),\n      retries: Math.max(this.maxAttemptNumber - 1, 0),\n      randomize: true\n    });\n  }\n  /**\n   * Method that invokes the runnable with the specified input, run manager,\n   * and config. It handles the retry logic by catching any errors and\n   * recursively invoking itself with the updated config for the next retry\n   * attempt.\n   * @param input The input for the runnable.\n   * @param runManager The run manager for the runnable.\n   * @param config The config for the runnable.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(input, config) {\n    return this._callWithConfig(this._invoke.bind(this), input, config);\n  }\n  async _batch(inputs, configs, runManagers, batchOptions) {\n    const resultsMap = {};\n    try {\n      await pRetry(async attemptNumber => {\n        const remainingIndexes = inputs.map((_, i) => i).filter(i => resultsMap[i.toString()] === undefined ||\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        resultsMap[i.toString()] instanceof Error);\n        const remainingInputs = remainingIndexes.map(i => inputs[i]);\n        const patchedConfigs = remainingIndexes.map(i => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n        const results = await super.batch(remainingInputs, patchedConfigs, {\n          ...batchOptions,\n          returnExceptions: true\n        });\n        let firstException;\n        for (let i = 0; i < results.length; i += 1) {\n          const result = results[i];\n          const resultMapIndex = remainingIndexes[i];\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          if (result instanceof Error) {\n            if (firstException === undefined) {\n              firstException = result;\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              firstException.input = remainingInputs[i];\n            }\n          }\n          resultsMap[resultMapIndex.toString()] = result;\n        }\n        if (firstException) {\n          throw firstException;\n        }\n        return results;\n      }, {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        onFailedAttempt: error => this.onFailedAttempt(error, error.input),\n        retries: Math.max(this.maxAttemptNumber - 1, 0),\n        randomize: true\n      });\n    } catch (e) {\n      if (batchOptions?.returnExceptions !== true) {\n        throw e;\n      }\n    }\n    return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map(key => resultsMap[parseInt(key, 10)]);\n  }\n  async batch(inputs, options, batchOptions) {\n    return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n  }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({ model: \"gpt-4o-mini\" })]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence extends Runnable {\n  static lc_name() {\n    return \"RunnableSequence\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"first\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"middle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"last\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"omitSequenceTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    this.first = fields.first;\n    this.middle = fields.middle ?? this.middle;\n    this.last = fields.last;\n    this.name = fields.name;\n    this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;\n  }\n  get steps() {\n    return [this.first, ...this.middle, this.last];\n  }\n  async invoke(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n    delete config.runId;\n    let nextStepInput = input;\n    let finalOutput;\n    try {\n      const initialSteps = [this.first, ...this.middle];\n      for (let i = 0; i < initialSteps.length; i += 1) {\n        const step = initialSteps[i];\n        const promise = step.invoke(nextStepInput, patchConfig(config, {\n          callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`)\n        }));\n        nextStepInput = await raceWithSignal(promise, options?.signal);\n      }\n      // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n      if (options?.signal?.aborted) {\n        throw new Error(\"Aborted\");\n      }\n      finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {\n        callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`)\n      }));\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    return finalOutput;\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));\n    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n      delete configList[i].runId;\n      return handleStartRes;\n    }));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextStepInputs = inputs;\n    try {\n      for (let i = 0; i < this.steps.length; i += 1) {\n        const step = this.steps[i];\n        const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n          const childRunManager = runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`);\n          return patchConfig(configList[j], {\n            callbacks: childRunManager\n          });\n        }), batchOptions);\n        nextStepInputs = await raceWithSignal(promise, configList[0]?.signal);\n      }\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n    return nextStepInputs;\n  }\n  async *_streamIterator(input, options) {\n    const callbackManager_ = await getCallbackManagerForConfig(options);\n    const {\n      runId,\n      ...otherOptions\n    } = options ?? {};\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n    const steps = [this.first, ...this.middle, this.last];\n    let concatSupported = true;\n    let finalOutput;\n    async function* inputGenerator() {\n      yield input;\n    }\n    try {\n      let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, {\n        callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:1`)\n      }));\n      for (let i = 1; i < steps.length; i += 1) {\n        const step = steps[i];\n        finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, {\n          callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`)\n        }));\n      }\n      for await (const chunk of finalGenerator) {\n        options?.signal?.throwIfAborted();\n        yield chunk;\n        if (concatSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = concat(finalOutput, chunk);\n            } catch (e) {\n              finalOutput = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n  }\n  getGraph(config) {\n    const graph = new Graph();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let currentLastNode = null;\n    this.steps.forEach((step, index) => {\n      const stepGraph = step.getGraph(config);\n      if (index !== 0) {\n        stepGraph.trimFirstNode();\n      }\n      if (index !== this.steps.length - 1) {\n        stepGraph.trimLastNode();\n      }\n      graph.extend(stepGraph);\n      const stepFirstNode = stepGraph.firstNode();\n      if (!stepFirstNode) {\n        throw new Error(`Runnable ${step} has no first node`);\n      }\n      if (currentLastNode) {\n        graph.addEdge(currentLastNode, stepFirstNode);\n      }\n      currentLastNode = stepGraph.lastNode();\n    });\n    return graph;\n  }\n  pipe(coerceable) {\n    if (RunnableSequence.isRunnableSequence(coerceable)) {\n      return new RunnableSequence({\n        first: this.first,\n        middle: this.middle.concat([this.last, coerceable.first, ...coerceable.middle]),\n        last: coerceable.last,\n        name: this.name ?? coerceable.name\n      });\n    } else {\n      return new RunnableSequence({\n        first: this.first,\n        middle: [...this.middle, this.last],\n        last: _coerceToRunnable(coerceable),\n        name: this.name\n      });\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnableSequence(thing) {\n    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from([first, ...runnables], nameOrFields) {\n    let extra = {};\n    if (typeof nameOrFields === \"string\") {\n      extra.name = nameOrFields;\n    } else if (nameOrFields !== undefined) {\n      extra = nameOrFields;\n    }\n    return new RunnableSequence({\n      ...extra,\n      first: _coerceToRunnable(first),\n      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n      last: _coerceToRunnable(runnables[runnables.length - 1])\n    });\n  }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap extends Runnable {\n  static lc_name() {\n    return \"RunnableMap\";\n  }\n  getStepsKeys() {\n    return Object.keys(this.steps);\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"steps\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.steps = {};\n    for (const [key, value] of Object.entries(fields.steps)) {\n      this.steps[key] = _coerceToRunnable(value);\n    }\n  }\n  static from(steps) {\n    return new RunnableMap({\n      steps\n    });\n  }\n  async invoke(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n      input\n    }, config.runId, undefined, undefined, undefined, config?.runName);\n    delete config.runId;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const output = {};\n    try {\n      const promises = Object.entries(this.steps).map(async ([key, runnable]) => {\n        output[key] = await runnable.invoke(input, patchConfig(config, {\n          callbacks: runManager?.getChild(`map:key:${key}`)\n        }));\n      });\n      await raceWithSignal(Promise.all(promises), options?.signal);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(output);\n    return output;\n  }\n  async *_transform(generator, runManager, options) {\n    // shallow copy steps to ignore changes while iterating\n    const steps = {\n      ...this.steps\n    };\n    // each step gets a copy of the input iterator\n    const inputCopies = atee(generator, Object.keys(steps).length);\n    // start the first iteration of each output iterator\n    const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n      const gen = runnable.transform(inputCopies[i], patchConfig(options, {\n        callbacks: runManager?.getChild(`map:key:${key}`)\n      }));\n      return [key, gen.next().then(result => ({\n        key,\n        gen,\n        result\n      }))];\n    }));\n    // yield chunks as they become available,\n    // starting new iterations as needed,\n    // until all iterators are done\n    while (tasks.size) {\n      const promise = Promise.race(tasks.values());\n      const {\n        key,\n        result,\n        gen\n      } = await raceWithSignal(promise, options?.signal);\n      tasks.delete(key);\n      if (!result.done) {\n        yield {\n          [key]: result.value\n        };\n        tasks.set(key, gen.next().then(result => ({\n          key,\n          gen,\n          result\n        })));\n      }\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nexport class RunnableTraceable extends Runnable {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (!isTraceableFunction(fields.func)) {\n      throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n    }\n    this.func = fields.func;\n  }\n  async invoke(input, options) {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const callbacks = await getCallbackManagerForConfig(config);\n    const promise = this.func(patchConfig(config, {\n      callbacks\n    }), input);\n    return raceWithSignal(promise, config?.signal);\n  }\n  async *_streamIterator(input, options) {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const result = await this.invoke(input, options);\n    if (isAsyncIterable(result)) {\n      for await (const item of result) {\n        config?.signal?.throwIfAborted();\n        yield item;\n      }\n      return;\n    }\n    if (isIterator(result)) {\n      while (true) {\n        config?.signal?.throwIfAborted();\n        const state = result.next();\n        if (state.done) break;\n        yield state.value;\n      }\n      return;\n    }\n    yield result;\n  }\n  static from(func) {\n    return new RunnableTraceable({\n      func\n    });\n  }\n}\nfunction assertNonTraceableFunction(func) {\n  if (isTraceableFunction(func)) {\n    throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n  }\n}\n/**\n * A runnable that wraps an arbitrary function that takes a single argument.\n * @example\n * ```typescript\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const add = (input: { x: number; y: number }) => input.x + input.y;\n *\n * const multiply = (input: { value: number; multiplier: number }) =>\n *   input.value * input.multiplier;\n *\n * // Create runnables for the functions\n * const addLambda = RunnableLambda.from(add);\n * const multiplyLambda = RunnableLambda.from(multiply);\n *\n * // Chain the lambdas for a mathematical operation\n * const chainedLambda = addLambda.pipe((result) =>\n *   multiplyLambda.invoke({ value: result, multiplier: 2 })\n * );\n *\n * // Example invocation of the chainedLambda\n * const result = await chainedLambda.invoke({ x: 2, y: 3 });\n *\n * // Will log \"10\" (since (2 + 3) * 2 = 10)\n * ```\n */\nexport class RunnableLambda extends Runnable {\n  static lc_name() {\n    return \"RunnableLambda\";\n  }\n  constructor(fields) {\n    if (isTraceableFunction(fields.func)) {\n      // eslint-disable-next-line no-constructor-return\n      return RunnableTraceable.from(fields.func);\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    assertNonTraceableFunction(fields.func);\n    this.func = fields.func;\n  }\n  static from(func) {\n    return new RunnableLambda({\n      func\n    });\n  }\n  async _invoke(input, config, runManager) {\n    return new Promise((resolve, reject) => {\n      const childConfig = patchConfig(config, {\n        callbacks: runManager?.getChild(),\n        recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n      });\n      void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n        try {\n          let output = await this.func(input, {\n            ...childConfig\n          });\n          if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n              throw new Error(\"Recursion limit reached.\");\n            }\n            output = await output.invoke(input, {\n              ...childConfig,\n              recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n            });\n          } else if (isAsyncIterable(output)) {\n            let finalOutput;\n            for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {\n              config?.signal?.throwIfAborted();\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  finalOutput = concat(finalOutput, chunk);\n                } catch (e) {\n                  finalOutput = chunk;\n                }\n              }\n            }\n            output = finalOutput;\n          } else if (isIterableIterator(output)) {\n            let finalOutput;\n            for (const chunk of consumeIteratorInContext(childConfig, output)) {\n              config?.signal?.throwIfAborted();\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  finalOutput = concat(finalOutput, chunk);\n                } catch (e) {\n                  finalOutput = chunk;\n                }\n              }\n            }\n            output = finalOutput;\n          }\n          resolve(output);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(this._invoke.bind(this), input, options);\n  }\n  async *_transform(generator, runManager, config) {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          finalChunk = concat(finalChunk, chunk);\n        } catch (e) {\n          finalChunk = chunk;\n        }\n      }\n    }\n    const childConfig = patchConfig(config, {\n      callbacks: runManager?.getChild(),\n      recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n    });\n    const output = await new Promise((resolve, reject) => {\n      void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n        try {\n          const res = await this.func(finalChunk, {\n            ...childConfig,\n            config: childConfig\n          });\n          resolve(res);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n    if (output && Runnable.isRunnable(output)) {\n      if (config?.recursionLimit === 0) {\n        throw new Error(\"Recursion limit reached.\");\n      }\n      const stream = await output.stream(finalChunk, childConfig);\n      for await (const chunk of stream) {\n        yield chunk;\n      }\n    } else if (isAsyncIterable(output)) {\n      for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {\n        config?.signal?.throwIfAborted();\n        yield chunk;\n      }\n    } else if (isIterableIterator(output)) {\n      for (const chunk of consumeIteratorInContext(childConfig, output)) {\n        config?.signal?.throwIfAborted();\n        yield chunk;\n      }\n    } else {\n      yield output;\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const addYears = (age: number): number => age + 5;\n * const yearsToFifty = (age: number): number => 50 - age;\n * const yearsToHundred = (age: number): number => 100 - age;\n *\n * const addYearsLambda = RunnableLambda.from(addYears);\n * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);\n * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);\n *\n * // Pipe will coerce objects into RunnableParallel by default, but we\n * // explicitly instantiate one here to demonstrate\n * const sequence = addYearsLambda.pipe(\n *   RunnableParallel.from({\n *     years_to_fifty: milestoneFiftyLambda,\n *     years_to_hundred: milestoneHundredLambda,\n *   })\n * );\n *\n * // Invoke the sequence with a single age input\n * const res = await sequence.invoke(25);\n *\n * // { years_to_fifty: 20, years_to_hundred: 70 }\n * ```\n */\nexport class RunnableParallel extends RunnableMap {}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n *\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableWithFallbacks,\n * } from \"@langchain/core/runnables\";\n *\n * const primaryOperation = (input: string): string => {\n *   if (input !== \"safe\") {\n *     throw new Error(\"Primary operation failed due to unsafe input\");\n *   }\n *   return `Processed: ${input}`;\n * };\n *\n * // Define a fallback operation that processes the input differently\n * const fallbackOperation = (input: string): string =>\n *   `Fallback processed: ${input}`;\n *\n * const primaryRunnable = RunnableLambda.from(primaryOperation);\n * const fallbackRunnable = RunnableLambda.from(fallbackOperation);\n *\n * // Apply the fallback logic using the .withFallbacks() method\n * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);\n *\n * // Alternatively, create a RunnableWithFallbacks instance manually\n * const manualFallbackChain = new RunnableWithFallbacks({\n *   runnable: primaryRunnable,\n *   fallbacks: [fallbackRunnable],\n * });\n *\n * // Example invocation using .withFallbacks()\n * const res = await runnableWithFallback\n *   .invoke(\"unsafe input\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Fallback processed: unsafe input\"\n *\n * // Example invocation using manual instantiation\n * const res = await manualFallbackChain\n *   .invoke(\"safe\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Processed: safe\"\n * ```\n */\nexport class RunnableWithFallbacks extends Runnable {\n  static lc_name() {\n    return \"RunnableWithFallbacks\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fallbacks\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnable = fields.runnable;\n    this.fallbacks = fields.fallbacks;\n  }\n  *runnables() {\n    yield this.runnable;\n    for (const fallback of this.fallbacks) {\n      yield fallback;\n    }\n  }\n  async invoke(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const {\n      runId,\n      ...otherConfigFields\n    } = config;\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n    const childConfig = patchConfig(otherConfigFields, {\n      callbacks: runManager?.getChild()\n    });\n    const res = await AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n      let firstError;\n      for (const runnable of this.runnables()) {\n        config?.signal?.throwIfAborted();\n        try {\n          const output = await runnable.invoke(input, childConfig);\n          await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n          return output;\n        } catch (e) {\n          if (firstError === undefined) {\n            firstError = e;\n          }\n        }\n      }\n      if (firstError === undefined) {\n        throw new Error(\"No error stored at end of fallback.\");\n      }\n      await runManager?.handleChainError(firstError);\n      throw firstError;\n    });\n    return res;\n  }\n  async *_streamIterator(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const {\n      runId,\n      ...otherConfigFields\n    } = config;\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n    let firstError;\n    let stream;\n    for (const runnable of this.runnables()) {\n      config?.signal?.throwIfAborted();\n      const childConfig = patchConfig(otherConfigFields, {\n        callbacks: runManager?.getChild()\n      });\n      try {\n        const originalStream = await runnable.stream(input, childConfig);\n        stream = consumeAsyncIterableInContext(childConfig, originalStream);\n        break;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (stream === undefined) {\n      const error = firstError ?? new Error(\"No error stored at end of fallback.\");\n      await runManager?.handleChainError(error);\n      throw error;\n    }\n    let output;\n    try {\n      for await (const chunk of stream) {\n        yield chunk;\n        try {\n          output = output === undefined ? output : concat(output, chunk);\n        } catch (e) {\n          output = undefined;\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n  }\n  async batch(inputs, options, batchOptions) {\n    if (batchOptions?.returnExceptions) {\n      throw new Error(\"Not implemented.\");\n    }\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(config => getCallbackManagerForConfig(config)));\n    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n      delete configList[i].runId;\n      return handleStartRes;\n    }));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let firstError;\n    for (const runnable of this.runnables()) {\n      configList[0].signal?.throwIfAborted();\n      try {\n        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {\n          callbacks: runManager?.getChild()\n        })), batchOptions);\n        await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n        return outputs;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (!firstError) {\n      throw new Error(\"No error stored at end of fallbacks.\");\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainError(firstError)));\n    throw firstError;\n  }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable(coerceable) {\n  if (typeof coerceable === \"function\") {\n    return new RunnableLambda({\n      func: coerceable\n    });\n  } else if (Runnable.isRunnable(coerceable)) {\n    return coerceable;\n  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n    const runnables = {};\n    for (const [key, value] of Object.entries(coerceable)) {\n      runnables[key] = _coerceToRunnable(value);\n    }\n    return new RunnableMap({\n      steps: runnables\n    });\n  } else {\n    throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n  }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * @example\n * ```typescript\n * import {\n *   RunnableAssign,\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const calculateAge = (x: { birthYear: number }): { age: number } => {\n *   const currentYear = new Date().getFullYear();\n *   return { age: currentYear - x.birthYear };\n * };\n *\n * const createGreeting = (x: { name: string }): { greeting: string } => {\n *   return { greeting: `Hello, ${x.name}!` };\n * };\n *\n * const mapper = RunnableParallel.from({\n *   age_step: RunnableLambda.from(calculateAge),\n *   greeting_step: RunnableLambda.from(createGreeting),\n * });\n *\n * const runnableAssign = new RunnableAssign({ mapper });\n *\n * const res = await runnableAssign.invoke({ name: \"Alice\", birthYear: 1990 });\n *\n * // { name: \"Alice\", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: \"Hello, Alice!\" } }\n * ```\n */\nexport class RunnableAssign extends Runnable {\n  static lc_name() {\n    return \"RunnableAssign\";\n  }\n  constructor(fields) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (fields instanceof RunnableMap) {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        mapper: fields\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"mapper\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.mapper = fields.mapper;\n  }\n  async invoke(input, options) {\n    const mapperResult = await this.mapper.invoke(input, options);\n    return {\n      ...input,\n      ...mapperResult\n    };\n  }\n  async *_transform(generator, runManager, options) {\n    // collect mapper keys\n    const mapperKeys = this.mapper.getStepsKeys();\n    // create two input gens, one for the mapper, one for the input\n    const [forPassthrough, forMapper] = atee(generator);\n    // create mapper output gen\n    const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, {\n      callbacks: runManager?.getChild()\n    }));\n    // start the mapper\n    const firstMapperChunkPromise = mapperOutput.next();\n    // yield the passthrough\n    for await (const chunk of forPassthrough) {\n      if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n        throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n      }\n      const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n      if (Object.keys(filtered).length > 0) {\n        yield filtered;\n      }\n    }\n    // yield the mapper output\n    yield (await firstMapperChunkPromise).value;\n    for await (const chunk of mapperOutput) {\n      yield chunk;\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.\n * @example\n * ```typescript\n * import { RunnablePick } from \"@langchain/core/runnables\";\n *\n * const inputData = {\n *   name: \"John\",\n *   age: 30,\n *   city: \"New York\",\n *   country: \"USA\",\n *   email: \"john.doe@example.com\",\n *   phone: \"+1234567890\",\n * };\n *\n * const basicInfoRunnable = new RunnablePick([\"name\", \"city\"]);\n *\n * // Example invocation\n * const res = await basicInfoRunnable.invoke(inputData);\n *\n * // { name: 'John', city: 'New York' }\n * ```\n */\nexport class RunnablePick extends Runnable {\n  static lc_name() {\n    return \"RunnablePick\";\n  }\n  constructor(fields) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        keys: fields\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"keys\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.keys = fields.keys;\n  }\n  async _pick(input) {\n    if (typeof this.keys === \"string\") {\n      return input[this.keys];\n    } else {\n      const picked = this.keys.map(key => [key, input[key]]).filter(v => v[1] !== undefined);\n      return picked.length === 0 ? undefined : Object.fromEntries(picked);\n    }\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(this._pick.bind(this), input, options);\n  }\n  async *_transform(generator) {\n    for await (const chunk of generator) {\n      const picked = await this._pick(chunk);\n      if (picked !== undefined) {\n        yield picked;\n      }\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\nexport class RunnableToolLike extends RunnableBinding {\n  constructor(fields) {\n    const sequence = RunnableSequence.from([RunnableLambda.from(async input => {\n      let toolInput;\n      if (_isToolCall(input)) {\n        try {\n          toolInput = await interopParseAsync(this.schema, input.args);\n        } catch (e) {\n          throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));\n        }\n      } else {\n        toolInput = input;\n      }\n      return toolInput;\n    }).withConfig({\n      runName: `${fields.name}:parse_input`\n    }), fields.bound]).withConfig({\n      runName: fields.name\n    });\n    super({\n      bound: sequence,\n      config: fields.config ?? {}\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"description\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"schema\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = fields.name;\n    this.description = fields.description;\n    this.schema = fields.schema;\n  }\n  static lc_name() {\n    return \"RunnableToolLike\";\n  }\n}\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {InteropZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<InteropZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nexport function convertRunnableToTool(runnable, fields) {\n  const name = fields.name ?? runnable.getName();\n  const description = fields.description ?? getSchemaDescription(fields.schema);\n  if (isSimpleStringZodSchema(fields.schema)) {\n    return new RunnableToolLike({\n      name,\n      description,\n      schema: z.object({\n        input: z.string()\n      }).transform(input => input.input),\n      bound: runnable\n    });\n  }\n  return new RunnableToolLike({\n    name,\n    description,\n    schema: fields.schema,\n    bound: runnable\n  });\n}","map":{"version":3,"names":["z","pRetry","v4","uuidv4","isTraceableFunction","LogStreamCallbackHandler","RunLog","RunLogPatch","isLogStreamHandler","EventStreamCallbackHandler","isStreamEventsHandler","Serializable","IterableReadableStream","concat","atee","pipeGeneratorWithSetup","AsyncGeneratorWithSetup","raceWithSignal","DEFAULT_RECURSION_LIMIT","ensureConfig","getCallbackManagerForConfig","mergeConfigs","patchConfig","pickRunnableConfigKeys","AsyncCaller","RootListenersTracer","_RootEventFilter","isRunnableInterface","AsyncLocalStorageProviderSingleton","Graph","convertToHttpEventStream","consumeAsyncIterableInContext","consumeIteratorInContext","isAsyncIterable","isIterableIterator","isIterator","_isToolCall","ToolInputParsingException","getSchemaDescription","interopParseAsync","isSimpleStringZodSchema","_coerceToDict","value","defaultKey","Array","isArray","Date","Runnable","constructor","arguments","Object","defineProperty","enumerable","configurable","writable","getName","suffix","name","lc_name","bind","kwargs","RunnableBinding","bound","config","map","RunnableEach","withRetry","fields","RunnableRetry","maxAttemptNumber","stopAfterAttempt","withConfig","withFallbacks","fallbacks","RunnableWithFallbacks","runnable","_getOptionsList","options","length","Error","runId","console","warn","subsequent","fromEntries","entries","filter","key","from","_","i","batch","inputs","batchOptions","configList","maxConcurrency","caller","onFailedAttempt","e","batchCalls","input","call","result","invoke","returnExceptions","Promise","all","_streamIterator","stream","wrappedGenerator","generator","setup","fromAsyncGenerator","_separateRunnableConfigFromCallOptions","runnableConfig","undefined","callbacks","tags","metadata","runName","recursionLimit","timeout","signal","callOptions","_callWithConfig","func","callbackManager_","runManager","handleChainStart","toJSON","runType","output","promise","handleChainError","handleChainEnd","_batchWithConfig","optionsList","callbackManagers","runManagers","callbackManager","handleStartRes","outputs","_transformStreamWithConfig","inputGenerator","transformer","finalInput","finalInputSupported","finalOutput","finalOutputSupported","wrapInputForTracing","chunk","pipe","streamEventsHandler","handlers","find","iterator","tapOutputIterable","streamLogHandler","getGraph","graph","inputNode","addNode","schema","any","runnableNode","outputNode","addEdge","coerceable","RunnableSequence","first","last","_coerceToRunnable","pick","keys","RunnablePick","assign","mapping","RunnableAssign","RunnableMap","steps","transform","finalChunk","streamLog","streamOptions","logStreamCallbackHandler","autoClose","_schemaFormat","_streamLog","copiedCallbacks","copy","addHandler","runnableStreamPromise","consumeRunnableStream","runnableStream","patch","ops","op","path","writer","write","close","runnableStreamConsumePromise","log","streamEvents","version","_streamEventsV1","_streamEventsV2","encoding","eventStreamer","abortController","AbortController","outerThis","listener","AbortSignal","abort","addEventListener","once","tappedStream","aborted","finish","removeEventListener","firstEventSent","firstEventRunId","event","data","run_id","endsWith","runLog","hasEncounteredStartEvent","rootTags","rootMetadata","rootName","rootEventFilter","logStream","fromRunLogPatch","state","id","type","includeEvent","paths","startsWith","split","dedupedPaths","Set","eventType","logEntry","logs","end_time","streamed_output","final_output","chunkCount","isRunnable","thing","withListeners","onStart","onEnd","onError","configFactories","asTool","convertRunnableToTool","_mergeConfig","configFactory","mergedOptions","individualOption","isRunnableBinding","_invoke","getChild","_patchConfigForRetry","attempt","tag","attemptNumber","error","retries","Math","max","randomize","_batch","configs","resultsMap","remainingIndexes","toString","remainingInputs","patchedConfigs","results","firstException","resultMapIndex","sort","a","b","parseInt","middle","omitSequenceTags","nextStepInput","initialSteps","step","nextStepInputs","j","childRunManager","otherOptions","concatSupported","finalGenerator","throwIfAborted","currentLastNode","forEach","index","stepGraph","trimFirstNode","trimLastNode","extend","stepFirstNode","firstNode","lastNode","isRunnableSequence","runnables","nameOrFields","extra","slice","getStepsKeys","promises","_transform","inputCopies","tasks","Map","gen","next","then","size","race","values","delete","done","set","RunnableTraceable","item","assertNonTraceableFunction","RunnableLambda","resolve","reject","childConfig","runWithConfig","res","RunnableParallel","fallback","otherConfigFields","firstError","originalStream","mapper","mapperResult","mapperKeys","forPassthrough","forMapper","mapperOutput","firstMapperChunkPromise","filtered","includes","_pick","picked","v","RunnableToolLike","sequence","toolInput","args","JSON","stringify","description","object","string"],"sources":["/Users/chetan/Desktop/research&report_writing agent/frontend/node_modules/@langchain/core/dist/runnables/base.js"],"sourcesContent":["import { z } from \"zod/v3\";\nimport pRetry from \"p-retry\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { isTraceableFunction, } from \"langsmith/singletons/traceable\";\nimport { LogStreamCallbackHandler, RunLog, RunLogPatch, isLogStreamHandler, } from \"../tracers/log_stream.js\";\nimport { EventStreamCallbackHandler, isStreamEventsHandler, } from \"../tracers/event_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream, concat, atee, pipeGeneratorWithSetup, AsyncGeneratorWithSetup, } from \"../utils/stream.js\";\nimport { raceWithSignal } from \"../utils/signal.js\";\nimport { DEFAULT_RECURSION_LIMIT, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, pickRunnableConfigKeys, } from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter, isRunnableInterface } from \"./utils.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { Graph } from \"./graph.js\";\nimport { convertToHttpEventStream } from \"./wrappers.js\";\nimport { consumeAsyncIterableInContext, consumeIteratorInContext, isAsyncIterable, isIterableIterator, isIterator, } from \"./iter.js\";\nimport { _isToolCall, ToolInputParsingException } from \"../tools/utils.js\";\nimport { getSchemaDescription, interopParseAsync, isSimpleStringZodSchema, } from \"../utils/types/zod.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    getName(suffix) {\n        const name = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n        return suffix ? `${name}${suffix}` : name;\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs, config: {} });\n    }\n    /**\n     * Return a new Runnable that maps a list of inputs to a list of outputs,\n     * by calling invoke() with each input.\n     *\n     * @deprecated This will be removed in the next breaking release.\n     */\n    map() {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableEach({ bound: this });\n    }\n    /**\n     * Add retry logic to an existing runnable.\n     * @param fields.stopAfterAttempt The number of attempts to retry.\n     * @param fields.onFailedAttempt A function that is called when a retry fails.\n     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n     */\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this,\n            kwargs: {},\n            config: {},\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    /**\n     * Bind config to a Runnable, returning a new Runnable.\n     * @param config New configuration parameters to attach to the new runnable.\n     * @returns A new RunnableBinding with a config matching what's passed.\n     */\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config,\n            kwargs: {},\n        });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options) && options.length !== length) {\n            throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n        }\n        if (Array.isArray(options)) {\n            return options.map(ensureConfig);\n        }\n        if (length > 1 && !Array.isArray(options) && options.runId) {\n            console.warn(\"Provided runId will be used only for the first element of the batch.\");\n            const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n            return Array.from({ length }, (_, i) => ensureConfig(i === 0 ? options : subsequent));\n        }\n        return Array.from({ length }, () => ensureConfig(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const caller = new AsyncCaller({\n            maxConcurrency,\n            onFailedAttempt: (e) => {\n                throw e;\n            },\n        });\n        const batchCalls = inputs.map((input, i) => caller.call(async () => {\n            try {\n                const result = await this.invoke(input, configList[i]);\n                return result;\n            }\n            catch (e) {\n                if (batchOptions?.returnExceptions) {\n                    return e;\n                }\n                throw e;\n            }\n        }));\n        return Promise.all(batchCalls);\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        // Buffer the first streamed chunk to allow for initial errors\n        // to surface immediately.\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this._streamIterator(input, config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n    _separateRunnableConfigFromCallOptions(options) {\n        let runnableConfig;\n        if (options === undefined) {\n            runnableConfig = ensureConfig(options);\n        }\n        else {\n            runnableConfig = ensureConfig({\n                callbacks: options.callbacks,\n                tags: options.tags,\n                metadata: options.metadata,\n                runName: options.runName,\n                configurable: options.configurable,\n                recursionLimit: options.recursionLimit,\n                maxConcurrency: options.maxConcurrency,\n                runId: options.runId,\n                timeout: options.timeout,\n                signal: options.signal,\n            });\n        }\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        delete callOptions.runName;\n        delete callOptions.configurable;\n        delete callOptions.recursionLimit;\n        delete callOptions.maxConcurrency;\n        delete callOptions.runId;\n        delete callOptions.timeout;\n        delete callOptions.signal;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n        delete config.runId;\n        let output;\n        try {\n            const promise = func.call(this, input, config, runManager);\n            output = await raceWithSignal(promise, options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Internal method that handles batching and configuration for a runnable\n     * It takes a function, input values, and optional configuration, and\n     * returns a promise that resolves to the output values.\n     * @param func The function to be executed for each input value.\n     * @param input The input values to be processed.\n     * @param config Optional configuration for the function execution.\n     * @returns A promise that resolves to the output values.\n     */\n    async _batchWithConfig(func, inputs, options, batchOptions) {\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n            delete optionsList[i].runId;\n            return handleStartRes;\n        }));\n        let outputs;\n        try {\n            const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);\n            outputs = await raceWithSignal(promise, optionsList?.[0]?.signal);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n        return outputs;\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalInput = concat(finalInput, chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        let runManager;\n        try {\n            const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: \"\" }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), options?.signal, config);\n            delete config.runId;\n            runManager = pipe.setup;\n            const streamEventsHandler = runManager?.handlers.find(isStreamEventsHandler);\n            let iterator = pipe.output;\n            if (streamEventsHandler !== undefined && runManager !== undefined) {\n                iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n            if (streamLogHandler !== undefined && runManager !== undefined) {\n                iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            for await (const chunk of iterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = concat(finalOutput, chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    getGraph(_) {\n        const graph = new Graph();\n        // TODO: Add input schema for runnables\n        const inputNode = graph.addNode({\n            name: `${this.getName()}Input`,\n            schema: z.any(),\n        });\n        const runnableNode = graph.addNode(this);\n        // TODO: Add output schemas for runnables\n        const outputNode = graph.addNode({\n            name: `${this.getName()}Output`,\n            schema: z.any(),\n        });\n        graph.addEdge(inputNode, runnableNode);\n        graph.addEdge(runnableNode, outputNode);\n        return graph;\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    /**\n     * Pick keys from the dict output of this runnable. Returns a new runnable.\n     */\n    pick(keys) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.pipe(new RunnablePick(keys));\n    }\n    /**\n     * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n     */\n    assign(mapping) {\n        return this.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap({ steps: mapping })));\n    }\n    /**\n     * Default implementation of transform, which buffers input and then calls stream.\n     * Subclasses should override this method if they can start producing output while\n     * input is still being generated.\n     * @param generator\n     * @param options\n     */\n    async *transform(generator, options) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                // This method should throw an error if gathering fails.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                finalChunk = concat(finalChunk, chunk);\n            }\n        }\n        yield* this._streamIterator(finalChunk, ensureConfig(options));\n    }\n    /**\n     * Stream all output from a runnable, as reported to the callback system.\n     * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n     * Output is streamed as Log objects, which include a list of\n     * jsonpatch ops that describe how the state of the run has changed in each\n     * step, and the final state of the run.\n     * The jsonpatch ops can be applied in order to construct state.\n     * @param input\n     * @param options\n     * @param streamOptions\n     */\n    async *streamLog(input, options, streamOptions) {\n        const logStreamCallbackHandler = new LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"original\",\n        });\n        const config = ensureConfig(options);\n        yield* this._streamLog(input, logStreamCallbackHandler, config);\n    }\n    async *_streamLog(input, logStreamCallbackHandler, config) {\n        const { callbacks } = config;\n        if (callbacks === undefined) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = [logStreamCallbackHandler];\n        }\n        else if (Array.isArray(callbacks)) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const runnableStreamPromise = this.stream(input, config);\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await runnableStreamPromise;\n                for await (const chunk of runnableStream) {\n                    const patch = new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: \"/streamed_output/-\",\n                                value: chunk,\n                            },\n                        ],\n                    });\n                    await logStreamCallbackHandler.writer.write(patch);\n                }\n            }\n            finally {\n                await logStreamCallbackHandler.writer.close();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        try {\n            for await (const log of logStreamCallbackHandler) {\n                yield log;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    streamEvents(input, options, streamOptions) {\n        let stream;\n        if (options.version === \"v1\") {\n            stream = this._streamEventsV1(input, options, streamOptions);\n        }\n        else if (options.version === \"v2\") {\n            stream = this._streamEventsV2(input, options, streamOptions);\n        }\n        else {\n            throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n        }\n        if (options.encoding === \"text/event-stream\") {\n            return convertToHttpEventStream(stream);\n        }\n        else {\n            return IterableReadableStream.fromAsyncGenerator(stream);\n        }\n    }\n    async *_streamEventsV2(input, options, streamOptions) {\n        const eventStreamer = new EventStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n        });\n        const config = ensureConfig(options);\n        const runId = config.runId ?? uuidv4();\n        config.runId = runId;\n        const callbacks = config.callbacks;\n        if (callbacks === undefined) {\n            config.callbacks = [eventStreamer];\n        }\n        else if (Array.isArray(callbacks)) {\n            config.callbacks = callbacks.concat(eventStreamer);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(eventStreamer, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const abortController = new AbortController();\n        // Call the runnable in streaming mode,\n        // add each chunk to the output stream\n        const outerThis = this;\n        async function consumeRunnableStream() {\n            let signal;\n            let listener = null;\n            try {\n                if (options?.signal) {\n                    if (\"any\" in AbortSignal) {\n                        // Use native AbortSignal.any() if available (Node 19+)\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        signal = AbortSignal.any([\n                            abortController.signal,\n                            options.signal,\n                        ]);\n                    }\n                    else {\n                        // Fallback for Node 18 and below - just use the provided signal\n                        signal = options.signal;\n                        // Ensure we still abort our controller when the parent signal aborts\n                        listener = () => {\n                            abortController.abort();\n                        };\n                        options.signal.addEventListener(\"abort\", listener, { once: true });\n                    }\n                }\n                else {\n                    signal = abortController.signal;\n                }\n                const runnableStream = await outerThis.stream(input, {\n                    ...config,\n                    signal,\n                });\n                const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                for await (const _ of tappedStream) {\n                    // Just iterate so that the callback handler picks up events\n                    if (abortController.signal.aborted)\n                        break;\n                }\n            }\n            finally {\n                await eventStreamer.finish();\n                if (signal && listener) {\n                    signal.removeEventListener(\"abort\", listener);\n                }\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        let firstEventSent = false;\n        let firstEventRunId;\n        try {\n            for await (const event of eventStreamer) {\n                // This is a work-around an issue where the inputs into the\n                // chain are not available until the entire input is consumed.\n                // As a temporary solution, we'll modify the input to be the input\n                // that was passed into the chain.\n                if (!firstEventSent) {\n                    event.data.input = input;\n                    firstEventSent = true;\n                    firstEventRunId = event.run_id;\n                    yield event;\n                    continue;\n                }\n                if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n                    // If it's the end event corresponding to the root runnable\n                    // we dont include the input in the event since it's guaranteed\n                    // to be included in the first event.\n                    if (event.data?.input) {\n                        delete event.data.input;\n                    }\n                }\n                yield event;\n            }\n        }\n        finally {\n            abortController.abort();\n            await runnableStreamConsumePromise;\n        }\n    }\n    async *_streamEventsV1(input, options, streamOptions) {\n        let runLog;\n        let hasEncounteredStartEvent = false;\n        const config = ensureConfig(options);\n        const rootTags = config.tags ?? [];\n        const rootMetadata = config.metadata ?? {};\n        const rootName = config.runName ?? this.getName();\n        const logStreamCallbackHandler = new LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"streaming_events\",\n        });\n        const rootEventFilter = new _RootEventFilter({\n            ...streamOptions,\n        });\n        const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n        for await (const log of logStream) {\n            if (!runLog) {\n                runLog = RunLog.fromRunLogPatch(log);\n            }\n            else {\n                runLog = runLog.concat(log);\n            }\n            if (runLog.state === undefined) {\n                throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n            }\n            // Yield the start event for the root runnable if it hasn't been seen.\n            // The root run is never filtered out\n            if (!hasEncounteredStartEvent) {\n                hasEncounteredStartEvent = true;\n                const state = { ...runLog.state };\n                const event = {\n                    run_id: state.id,\n                    event: `on_${state.type}_start`,\n                    name: rootName,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    data: {\n                        input,\n                    },\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n            const paths = log.ops\n                .filter((op) => op.path.startsWith(\"/logs/\"))\n                .map((op) => op.path.split(\"/\")[2]);\n            const dedupedPaths = [...new Set(paths)];\n            for (const path of dedupedPaths) {\n                let eventType;\n                let data = {};\n                const logEntry = runLog.state.logs[path];\n                if (logEntry.end_time === undefined) {\n                    if (logEntry.streamed_output.length > 0) {\n                        eventType = \"stream\";\n                    }\n                    else {\n                        eventType = \"start\";\n                    }\n                }\n                else {\n                    eventType = \"end\";\n                }\n                if (eventType === \"start\") {\n                    // Include the inputs with the start event if they are available.\n                    // Usually they will NOT be available for components that operate\n                    // on streams, since those components stream the input and\n                    // don't know its final value until the end of the stream.\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                }\n                else if (eventType === \"end\") {\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                    data.output = logEntry.final_output;\n                }\n                else if (eventType === \"stream\") {\n                    const chunkCount = logEntry.streamed_output.length;\n                    if (chunkCount !== 1) {\n                        throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n                    }\n                    data = { chunk: logEntry.streamed_output[0] };\n                    // Clean up the stream, we don't need it anymore.\n                    // And this avoids duplicates as well!\n                    logEntry.streamed_output = [];\n                }\n                yield {\n                    event: `on_${logEntry.type}_${eventType}`,\n                    name: logEntry.name,\n                    run_id: logEntry.id,\n                    tags: logEntry.tags,\n                    metadata: logEntry.metadata,\n                    data,\n                };\n            }\n            // Finally, we take care of the streaming output from the root chain\n            // if there is any.\n            const { state } = runLog;\n            if (state.streamed_output.length > 0) {\n                const chunkCount = state.streamed_output.length;\n                if (chunkCount !== 1) {\n                    throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n                }\n                const data = { chunk: state.streamed_output[0] };\n                // Clean up the stream, we don't need it anymore.\n                state.streamed_output = [];\n                const event = {\n                    event: `on_${state.type}_stream`,\n                    run_id: state.id,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    name: rootName,\n                    data,\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n        }\n        const state = runLog?.state;\n        if (state !== undefined) {\n            // Finally, yield the end event for the root runnable.\n            const event = {\n                event: `on_${state.type}_end`,\n                name: rootName,\n                run_id: state.id,\n                tags: rootTags,\n                metadata: rootMetadata,\n                data: {\n                    output: state.final_output,\n                },\n            };\n            if (rootEventFilter.includeEvent(event, state.type))\n                yield event;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return isRunnableInterface(thing);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config: {},\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n    /**\n     * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n     * which contains the runnable, name, description and schema.\n     *\n     * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n     *\n     * @param fields\n     * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n     * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n     * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n     * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n     */\n    asTool(fields) {\n        return convertRunnableToTool(this, fields);\n    }\n}\n/**\n * Wraps a runnable and applies partial config upon invocation.\n *\n * @example\n * ```typescript\n * import {\n *   type RunnableConfig,\n *   RunnableLambda,\n * } from \"@langchain/core/runnables\";\n *\n * const enhanceProfile = (\n *   profile: Record<string, any>,\n *   config?: RunnableConfig\n * ) => {\n *   if (config?.configurable?.role) {\n *     return { ...profile, role: config.configurable.role };\n *   }\n *   return profile;\n * };\n *\n * const runnable = RunnableLambda.from(enhanceProfile);\n *\n * // Bind configuration to the runnable to set the user's role dynamically\n * const adminRunnable = runnable.bind({ configurable: { role: \"Admin\" } });\n * const userRunnable = runnable.bind({ configurable: { role: \"User\" } });\n *\n * const result1 = await adminRunnable.invoke({\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * });\n *\n * // { name: \"Alice\", email: \"alice@example.com\", role: \"Admin\" }\n *\n * const result2 = await userRunnable.invoke({\n *   name: \"Bob\",\n *   email: \"bob@example.com\"\n * });\n *\n * // { name: \"Bob\", email: \"bob@example.com\", role: \"User\" }\n * ```\n */\nexport class RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"configFactories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n        this.config = fields.config;\n        this.configFactories = fields.configFactories;\n    }\n    getName(suffix) {\n        return this.bound.getName(suffix);\n    }\n    async _mergeConfig(...options) {\n        const config = mergeConfigs(this.config, ...options);\n        return mergeConfigs(config, ...(this.configFactories\n            ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config)))\n            : []));\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableBinding` class that is bound with the specified arguments.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n            config: this.config,\n        });\n    }\n    withConfig(config) {\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: { ...this.config, ...config },\n        });\n    }\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(ensureConfig(individualOption), this.kwargs)))\n            : await this._mergeConfig(ensureConfig(options), this.kwargs);\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async *transform(generator, options) {\n        yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    streamEvents(input, options, streamOptions) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const outerThis = this;\n        const generator = async function* () {\n            yield* outerThis.bound.streamEvents(input, {\n                ...(await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs)),\n                version: options.version,\n            }, streamOptions);\n        };\n        return IterableReadableStream.fromAsyncGenerator(generator());\n    }\n    static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return thing.bound && Runnable.isRunnable(thing.bound);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n * @example\n * ```typescript\n * import { RunnableEach, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const toUpperCase = (input: string): string => input.toUpperCase();\n * const addGreeting = (input: string): string => `Hello, ${input}!`;\n *\n * const upperCaseLambda = RunnableLambda.from(toUpperCase);\n * const greetingLambda = RunnableLambda.from(addGreeting);\n *\n * const chain = new RunnableEach({\n *   bound: upperCaseLambda.pipe(greetingLambda),\n * });\n *\n * const result = await chain.invoke([\"alice\", \"bob\", \"carol\"])\n *\n * // [\"Hello, ALICE!\", \"Hello, BOB!\", \"Hello, CAROL!\"]\n * ```\n *\n * @deprecated This will be removed in the next breaking release.\n */\nexport class RunnableEach extends Runnable {\n    static lc_name() {\n        return \"RunnableEach\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        return new RunnableEach({\n            bound: this.bound.bind(kwargs),\n        });\n    }\n    /**\n     * Invokes the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(inputs, config) {\n        return this._callWithConfig(this._invoke.bind(this), inputs, config);\n    }\n    /**\n     * A helper method that is used to invoke the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async _invoke(inputs, config, runManager) {\n        return this.bound.batch(inputs, patchConfig(config, { callbacks: runManager?.getChild() }));\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableEach({\n            bound: this.bound.withListeners({ onStart, onEnd, onError }),\n        });\n    }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableRetry,\n * } from \"@langchain/core/runnables\";\n *\n * // Simulate an API call that fails\n * const simulateApiCall = (input: string): string => {\n *   console.log(`Attempting API call with input: ${input}`);\n *   throw new Error(\"API call failed due to network issue\");\n * };\n *\n * const apiCallLambda = RunnableLambda.from(simulateApiCall);\n *\n * // Apply retry logic using the .withRetry() method\n * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });\n *\n * // Alternatively, create a RunnableRetry instance manually\n * const manualRetry = new RunnableRetry({\n *   bound: apiCallLambda,\n *   maxAttemptNumber: 3,\n *   config: {},\n * });\n *\n * // Example invocation using the .withRetry() method\n * const res = await apiCallWithRetry\n *   .invoke(\"Request 1\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n *\n * // Example invocation using the manual retry instance\n * const res2 = await manualRetry\n *   .invoke(\"Request 2\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n * ```\n */\nexport class RunnableRetry extends RunnableBinding {\n    static lc_name() {\n        return \"RunnableRetry\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"maxAttemptNumber\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: () => { }\n        });\n        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n    }\n    _patchConfigForRetry(attempt, config, runManager) {\n        const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n        return patchConfig(config, { callbacks: runManager?.getChild(tag) });\n    }\n    async _invoke(input, config, runManager) {\n        return pRetry((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onFailedAttempt: (error) => this.onFailedAttempt(error, input),\n            retries: Math.max(this.maxAttemptNumber - 1, 0),\n            randomize: true,\n        });\n    }\n    /**\n     * Method that invokes the runnable with the specified input, run manager,\n     * and config. It handles the retry logic by catching any errors and\n     * recursively invoking itself with the updated config for the next retry\n     * attempt.\n     * @param input The input for the runnable.\n     * @param runManager The run manager for the runnable.\n     * @param config The config for the runnable.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(input, config) {\n        return this._callWithConfig(this._invoke.bind(this), input, config);\n    }\n    async _batch(inputs, configs, runManagers, batchOptions) {\n        const resultsMap = {};\n        try {\n            await pRetry(async (attemptNumber) => {\n                const remainingIndexes = inputs\n                    .map((_, i) => i)\n                    .filter((i) => resultsMap[i.toString()] === undefined ||\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    resultsMap[i.toString()] instanceof Error);\n                const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n                const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n                const results = await super.batch(remainingInputs, patchedConfigs, {\n                    ...batchOptions,\n                    returnExceptions: true,\n                });\n                let firstException;\n                for (let i = 0; i < results.length; i += 1) {\n                    const result = results[i];\n                    const resultMapIndex = remainingIndexes[i];\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (result instanceof Error) {\n                        if (firstException === undefined) {\n                            firstException = result;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            firstException.input = remainingInputs[i];\n                        }\n                    }\n                    resultsMap[resultMapIndex.toString()] = result;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n                return results;\n            }, {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),\n                retries: Math.max(this.maxAttemptNumber - 1, 0),\n                randomize: true,\n            });\n        }\n        catch (e) {\n            if (batchOptions?.returnExceptions !== true) {\n                throw e;\n            }\n        }\n        return Object.keys(resultsMap)\n            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n            .map((key) => resultsMap[parseInt(key, 10)]);\n    }\n    async batch(inputs, options, batchOptions) {\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({ model: \"gpt-4o-mini\" })]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"omitSequenceTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n        this.name = fields.name;\n        this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            const initialSteps = [this.first, ...this.middle];\n            for (let i = 0; i < initialSteps.length; i += 1) {\n                const step = initialSteps[i];\n                const promise = step.invoke(nextStepInput, patchConfig(config, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n                nextStepInput = await raceWithSignal(promise, options?.signal);\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            if (options?.signal?.aborted) {\n                throw new Error(\"Aborted\");\n            }\n            finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`),\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        try {\n            for (let i = 0; i < this.steps.length; i += 1) {\n                const step = this.steps[i];\n                const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n                    const childRunManager = runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`);\n                    return patchConfig(configList[j], { callbacks: childRunManager });\n                }), batchOptions);\n                nextStepInputs = await raceWithSignal(promise, configList[0]?.signal);\n            }\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n        return nextStepInputs;\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await getCallbackManagerForConfig(options);\n        const { runId, ...otherOptions } = options ?? {};\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n        const steps = [this.first, ...this.middle, this.last];\n        let concatSupported = true;\n        let finalOutput;\n        async function* inputGenerator() {\n            yield input;\n        }\n        try {\n            let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:1`),\n            }));\n            for (let i = 1; i < steps.length; i += 1) {\n                const step = steps[i];\n                finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n            }\n            for await (const chunk of finalGenerator) {\n                options?.signal?.throwIfAborted();\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = concat(finalOutput, chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    getGraph(config) {\n        const graph = new Graph();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let currentLastNode = null;\n        this.steps.forEach((step, index) => {\n            const stepGraph = step.getGraph(config);\n            if (index !== 0) {\n                stepGraph.trimFirstNode();\n            }\n            if (index !== this.steps.length - 1) {\n                stepGraph.trimLastNode();\n            }\n            graph.extend(stepGraph);\n            const stepFirstNode = stepGraph.firstNode();\n            if (!stepFirstNode) {\n                throw new Error(`Runnable ${step} has no first node`);\n            }\n            if (currentLastNode) {\n                graph.addEdge(currentLastNode, stepFirstNode);\n            }\n            currentLastNode = stepGraph.lastNode();\n        });\n        return graph;\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n                name: this.name ?? coerceable.name,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n                name: this.name,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from([first, ...runnables], nameOrFields) {\n        let extra = {};\n        if (typeof nameOrFields === \"string\") {\n            extra.name = nameOrFields;\n        }\n        else if (nameOrFields !== undefined) {\n            extra = nameOrFields;\n        }\n        return new RunnableSequence({\n            ...extra,\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n        });\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    getStepsKeys() {\n        return Object.keys(this.steps);\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    static from(steps) {\n        return new RunnableMap({ steps });\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        }, config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            const promises = Object.entries(this.steps).map(async ([key, runnable]) => {\n                output[key] = await runnable.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`map:key:${key}`),\n                }));\n            });\n            await raceWithSignal(Promise.all(promises), options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n    async *_transform(generator, runManager, options) {\n        // shallow copy steps to ignore changes while iterating\n        const steps = { ...this.steps };\n        // each step gets a copy of the input iterator\n        const inputCopies = atee(generator, Object.keys(steps).length);\n        // start the first iteration of each output iterator\n        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n            const gen = runnable.transform(inputCopies[i], patchConfig(options, {\n                callbacks: runManager?.getChild(`map:key:${key}`),\n            }));\n            return [key, gen.next().then((result) => ({ key, gen, result }))];\n        }));\n        // yield chunks as they become available,\n        // starting new iterations as needed,\n        // until all iterators are done\n        while (tasks.size) {\n            const promise = Promise.race(tasks.values());\n            const { key, result, gen } = await raceWithSignal(promise, options?.signal);\n            tasks.delete(key);\n            if (!result.done) {\n                yield { [key]: result.value };\n                tasks.set(key, gen.next().then((result) => ({ key, gen, result })));\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nexport class RunnableTraceable extends Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (!isTraceableFunction(fields.func)) {\n            throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n        }\n        this.func = fields.func;\n    }\n    async invoke(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const callbacks = await getCallbackManagerForConfig(config);\n        const promise = this.func(patchConfig(config, { callbacks }), input);\n        return raceWithSignal(promise, config?.signal);\n    }\n    async *_streamIterator(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const result = await this.invoke(input, options);\n        if (isAsyncIterable(result)) {\n            for await (const item of result) {\n                config?.signal?.throwIfAborted();\n                yield item;\n            }\n            return;\n        }\n        if (isIterator(result)) {\n            while (true) {\n                config?.signal?.throwIfAborted();\n                const state = result.next();\n                if (state.done)\n                    break;\n                yield state.value;\n            }\n            return;\n        }\n        yield result;\n    }\n    static from(func) {\n        return new RunnableTraceable({ func });\n    }\n}\nfunction assertNonTraceableFunction(func) {\n    if (isTraceableFunction(func)) {\n        throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n    }\n}\n/**\n * A runnable that wraps an arbitrary function that takes a single argument.\n * @example\n * ```typescript\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const add = (input: { x: number; y: number }) => input.x + input.y;\n *\n * const multiply = (input: { value: number; multiplier: number }) =>\n *   input.value * input.multiplier;\n *\n * // Create runnables for the functions\n * const addLambda = RunnableLambda.from(add);\n * const multiplyLambda = RunnableLambda.from(multiply);\n *\n * // Chain the lambdas for a mathematical operation\n * const chainedLambda = addLambda.pipe((result) =>\n *   multiplyLambda.invoke({ value: result, multiplier: 2 })\n * );\n *\n * // Example invocation of the chainedLambda\n * const result = await chainedLambda.invoke({ x: 2, y: 3 });\n *\n * // Will log \"10\" (since (2 + 3) * 2 = 10)\n * ```\n */\nexport class RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        if (isTraceableFunction(fields.func)) {\n            // eslint-disable-next-line no-constructor-return\n            return RunnableTraceable.from(fields.func);\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        assertNonTraceableFunction(fields.func);\n        this.func = fields.func;\n    }\n    static from(func) {\n        return new RunnableLambda({\n            func,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = patchConfig(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n            });\n            void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n                try {\n                    let output = await this.func(input, {\n                        ...childConfig,\n                    });\n                    if (output && Runnable.isRunnable(output)) {\n                        if (config?.recursionLimit === 0) {\n                            throw new Error(\"Recursion limit reached.\");\n                        }\n                        output = await output.invoke(input, {\n                            ...childConfig,\n                            recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n                        });\n                    }\n                    else if (isAsyncIterable(output)) {\n                        let finalOutput;\n                        for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    finalOutput = concat(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    else if (isIterableIterator(output)) {\n                        let finalOutput;\n                        for (const chunk of consumeIteratorInContext(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    finalOutput = concat(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke.bind(this), input, options);\n    }\n    async *_transform(generator, runManager, config) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    finalChunk = concat(finalChunk, chunk);\n                }\n                catch (e) {\n                    finalChunk = chunk;\n                }\n            }\n        }\n        const childConfig = patchConfig(config, {\n            callbacks: runManager?.getChild(),\n            recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n        });\n        const output = await new Promise((resolve, reject) => {\n            void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n                try {\n                    const res = await this.func(finalChunk, {\n                        ...childConfig,\n                        config: childConfig,\n                    });\n                    resolve(res);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            const stream = await output.stream(finalChunk, childConfig);\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n        }\n        else if (isAsyncIterable(output)) {\n            for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else if (isIterableIterator(output)) {\n            for (const chunk of consumeIteratorInContext(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else {\n            yield output;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const addYears = (age: number): number => age + 5;\n * const yearsToFifty = (age: number): number => 50 - age;\n * const yearsToHundred = (age: number): number => 100 - age;\n *\n * const addYearsLambda = RunnableLambda.from(addYears);\n * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);\n * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);\n *\n * // Pipe will coerce objects into RunnableParallel by default, but we\n * // explicitly instantiate one here to demonstrate\n * const sequence = addYearsLambda.pipe(\n *   RunnableParallel.from({\n *     years_to_fifty: milestoneFiftyLambda,\n *     years_to_hundred: milestoneHundredLambda,\n *   })\n * );\n *\n * // Invoke the sequence with a single age input\n * const res = await sequence.invoke(25);\n *\n * // { years_to_fifty: 20, years_to_hundred: 70 }\n * ```\n */\nexport class RunnableParallel extends RunnableMap {\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n *\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableWithFallbacks,\n * } from \"@langchain/core/runnables\";\n *\n * const primaryOperation = (input: string): string => {\n *   if (input !== \"safe\") {\n *     throw new Error(\"Primary operation failed due to unsafe input\");\n *   }\n *   return `Processed: ${input}`;\n * };\n *\n * // Define a fallback operation that processes the input differently\n * const fallbackOperation = (input: string): string =>\n *   `Fallback processed: ${input}`;\n *\n * const primaryRunnable = RunnableLambda.from(primaryOperation);\n * const fallbackRunnable = RunnableLambda.from(fallbackOperation);\n *\n * // Apply the fallback logic using the .withFallbacks() method\n * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);\n *\n * // Alternatively, create a RunnableWithFallbacks instance manually\n * const manualFallbackChain = new RunnableWithFallbacks({\n *   runnable: primaryRunnable,\n *   fallbacks: [fallbackRunnable],\n * });\n *\n * // Example invocation using .withFallbacks()\n * const res = await runnableWithFallback\n *   .invoke(\"unsafe input\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Fallback processed: unsafe input\"\n *\n * // Example invocation using manual instantiation\n * const res = await manualFallbackChain\n *   .invoke(\"safe\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Processed: safe\"\n * ```\n */\nexport class RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        const childConfig = patchConfig(otherConfigFields, {\n            callbacks: runManager?.getChild(),\n        });\n        const res = await AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n            let firstError;\n            for (const runnable of this.runnables()) {\n                config?.signal?.throwIfAborted();\n                try {\n                    const output = await runnable.invoke(input, childConfig);\n                    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                    return output;\n                }\n                catch (e) {\n                    if (firstError === undefined) {\n                        firstError = e;\n                    }\n                }\n            }\n            if (firstError === undefined) {\n                throw new Error(\"No error stored at end of fallback.\");\n            }\n            await runManager?.handleChainError(firstError);\n            throw firstError;\n        });\n        return res;\n    }\n    async *_streamIterator(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        let firstError;\n        let stream;\n        for (const runnable of this.runnables()) {\n            config?.signal?.throwIfAborted();\n            const childConfig = patchConfig(otherConfigFields, {\n                callbacks: runManager?.getChild(),\n            });\n            try {\n                const originalStream = await runnable.stream(input, childConfig);\n                stream = consumeAsyncIterableInContext(childConfig, originalStream);\n                break;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (stream === undefined) {\n            const error = firstError ?? new Error(\"No error stored at end of fallback.\");\n            await runManager?.handleChainError(error);\n            throw error;\n        }\n        let output;\n        try {\n            for await (const chunk of stream) {\n                yield chunk;\n                try {\n                    output = output === undefined ? output : concat(output, chunk);\n                }\n                catch (e) {\n                    output = undefined;\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"Not implemented.\");\n        }\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => getCallbackManagerForConfig(config)));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            configList[0].signal?.throwIfAborted();\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {\n                    callbacks: runManager?.getChild(),\n                })), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({\n            steps: runnables,\n        });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * @example\n * ```typescript\n * import {\n *   RunnableAssign,\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const calculateAge = (x: { birthYear: number }): { age: number } => {\n *   const currentYear = new Date().getFullYear();\n *   return { age: currentYear - x.birthYear };\n * };\n *\n * const createGreeting = (x: { name: string }): { greeting: string } => {\n *   return { greeting: `Hello, ${x.name}!` };\n * };\n *\n * const mapper = RunnableParallel.from({\n *   age_step: RunnableLambda.from(calculateAge),\n *   greeting_step: RunnableLambda.from(createGreeting),\n * });\n *\n * const runnableAssign = new RunnableAssign({ mapper });\n *\n * const res = await runnableAssign.invoke({ name: \"Alice\", birthYear: 1990 });\n *\n * // { name: \"Alice\", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: \"Hello, Alice!\" } }\n * ```\n */\nexport class RunnableAssign extends Runnable {\n    static lc_name() {\n        return \"RunnableAssign\";\n    }\n    constructor(fields) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields instanceof RunnableMap) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { mapper: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.mapper = fields.mapper;\n    }\n    async invoke(input, options) {\n        const mapperResult = await this.mapper.invoke(input, options);\n        return {\n            ...input,\n            ...mapperResult,\n        };\n    }\n    async *_transform(generator, runManager, options) {\n        // collect mapper keys\n        const mapperKeys = this.mapper.getStepsKeys();\n        // create two input gens, one for the mapper, one for the input\n        const [forPassthrough, forMapper] = atee(generator);\n        // create mapper output gen\n        const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, { callbacks: runManager?.getChild() }));\n        // start the mapper\n        const firstMapperChunkPromise = mapperOutput.next();\n        // yield the passthrough\n        for await (const chunk of forPassthrough) {\n            if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n                throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n            }\n            const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n            if (Object.keys(filtered).length > 0) {\n                yield filtered;\n            }\n        }\n        // yield the mapper output\n        yield (await firstMapperChunkPromise).value;\n        for await (const chunk of mapperOutput) {\n            yield chunk;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.\n * @example\n * ```typescript\n * import { RunnablePick } from \"@langchain/core/runnables\";\n *\n * const inputData = {\n *   name: \"John\",\n *   age: 30,\n *   city: \"New York\",\n *   country: \"USA\",\n *   email: \"john.doe@example.com\",\n *   phone: \"+1234567890\",\n * };\n *\n * const basicInfoRunnable = new RunnablePick([\"name\", \"city\"]);\n *\n * // Example invocation\n * const res = await basicInfoRunnable.invoke(inputData);\n *\n * // { name: 'John', city: 'New York' }\n * ```\n */\nexport class RunnablePick extends Runnable {\n    static lc_name() {\n        return \"RunnablePick\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\" || Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { keys: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"keys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keys = fields.keys;\n    }\n    async _pick(input) {\n        if (typeof this.keys === \"string\") {\n            return input[this.keys];\n        }\n        else {\n            const picked = this.keys\n                .map((key) => [key, input[key]])\n                .filter((v) => v[1] !== undefined);\n            return picked.length === 0\n                ? undefined\n                : Object.fromEntries(picked);\n        }\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._pick.bind(this), input, options);\n    }\n    async *_transform(generator) {\n        for await (const chunk of generator) {\n            const picked = await this._pick(chunk);\n            if (picked !== undefined) {\n                yield picked;\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexport class RunnableToolLike extends RunnableBinding {\n    constructor(fields) {\n        const sequence = RunnableSequence.from([\n            RunnableLambda.from(async (input) => {\n                let toolInput;\n                if (_isToolCall(input)) {\n                    try {\n                        toolInput = await interopParseAsync(this.schema, input.args);\n                    }\n                    catch (e) {\n                        throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));\n                    }\n                }\n                else {\n                    toolInput = input;\n                }\n                return toolInput;\n            }).withConfig({ runName: `${fields.name}:parse_input` }),\n            fields.bound,\n        ]).withConfig({ runName: fields.name });\n        super({\n            bound: sequence,\n            config: fields.config ?? {},\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.schema = fields.schema;\n    }\n    static lc_name() {\n        return \"RunnableToolLike\";\n    }\n}\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {InteropZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<InteropZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nexport function convertRunnableToTool(runnable, fields) {\n    const name = fields.name ?? runnable.getName();\n    const description = fields.description ?? getSchemaDescription(fields.schema);\n    if (isSimpleStringZodSchema(fields.schema)) {\n        return new RunnableToolLike({\n            name,\n            description,\n            schema: z\n                .object({ input: z.string() })\n                .transform((input) => input.input),\n            bound: runnable,\n        });\n    }\n    return new RunnableToolLike({\n        name,\n        description,\n        schema: fields.schema,\n        bound: runnable,\n    });\n}\n"],"mappings":"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ChC,SAAS,EAAE,IAAI,CAACiN,UAAU,CAACpQ,IAAI,CAAC,IAAI,CAAC,EAAEkB,OAAO,CAAC;EAC1F;EACA,MAAM+B,MAAMA,CAACR,KAAK,EAAEvB,OAAO,EAAE;IACzB,gBAAgBiC,SAASA,CAAA,EAAG;MACxB,MAAMV,KAAK;IACf;IACA,MAAMrC,MAAM,GAAG5C,YAAY,CAAC0D,OAAO,CAAC;IACpC,MAAMgC,gBAAgB,GAAG,IAAI7F,uBAAuB,CAAC;MACjD8F,SAAS,EAAE,IAAI,CAACsE,SAAS,CAACtE,SAAS,CAAC,CAAC,EAAE/C,MAAM,CAAC;MAC9CA;IACJ,CAAC,CAAC;IACF,MAAM8C,gBAAgB,CAACE,KAAK;IAC5B,OAAOnG,sBAAsB,CAACoG,kBAAkB,CAACH,gBAAgB,CAAC;EACtE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMwO,gBAAgB,SAASnK,WAAW,CAAC;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMxG,qBAAqB,SAAS3B,QAAQ,CAAC;EAChD,OAAOW,OAAOA,CAAA,EAAG;IACb,OAAO,uBAAuB;EAClC;EACAV,WAAWA,CAACmB,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;IACbjB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}